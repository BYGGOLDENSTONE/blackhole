#pragma once

#include "CoreMinimal.h"
#include "Components/ActorComponent.h"
#include "AbilityComponent.generated.h"

class UResourceManager;
class UThresholdManager;

UCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))
class BLACKHOLE_API UAbilityComponent : public UActorComponent
{
	GENERATED_BODY()

public:
	UAbilityComponent();

protected:
	virtual void BeginPlay() override;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Ability")
	float Cooldown;

	// Legacy cost field - kept for backward compatibility
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Ability")
	float Cost;

	// Dual resource consumption
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Ability")
	float StaminaCost;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Ability")
	float WPCost;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Ability")
	float HeatCost;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Ability")
	float Range;

	// Heat generated when ability is used (multiplier of Cost)
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Ability", meta = (ClampMin = "0.0", ClampMax = "2.0"))
	float HeatGenerationMultiplier;

	UPROPERTY(BlueprintReadOnly, Category = "Ability")
	float CurrentCooldown;

	UPROPERTY(BlueprintReadOnly, Category = "Ability")
	bool bIsOnCooldown;
	
	// Track if ability is in ultimate mode
	UPROPERTY(BlueprintReadOnly, Category = "Ability")
	bool bIsInUltimateMode;
	
	// Track if this is a basic ability (not affected by ultimate system)
	UPROPERTY(EditDefaultsOnly, Category = "Ability")
	bool bIsBasicAbility;

public:
	virtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;

	UFUNCTION(BlueprintCallable, Category = "Ability")
	virtual bool CanExecute() const;

	UFUNCTION(BlueprintCallable, Category = "Ability")
	virtual void Execute();
	
	// Execute the ultimate version of this ability
	virtual void ExecuteUltimate();

	UFUNCTION(BlueprintCallable, Category = "Ability")
	float GetCooldownRemaining() const { return CurrentCooldown; }

	UFUNCTION(BlueprintCallable, Category = "Ability")
	float GetCooldownPercentage() const;

	UFUNCTION(BlueprintCallable, Category = "Ability")
	bool IsOnCooldown() const { return bIsOnCooldown; }

	UFUNCTION(BlueprintCallable, Category = "Ability")
	float GetRange() const { return Range; }

	UFUNCTION(BlueprintCallable, Category = "Ability")
	float GetCost() const { return Cost; }

	UFUNCTION(BlueprintCallable, Category = "Ability")
	float GetStaminaCost() const { return StaminaCost; }

	UFUNCTION(BlueprintCallable, Category = "Ability")
	float GetWPCost() const { return WPCost; }

	UFUNCTION(BlueprintCallable, Category = "Ability")
	float GetHeatCost() const { return HeatCost; }
	
	// Ultimate mode support
	UFUNCTION(BlueprintCallable, Category = "Ability")
	void SetUltimateMode(bool bEnabled) { bIsInUltimateMode = bEnabled; }
	
	UFUNCTION(BlueprintPure, Category = "Ability")
	bool IsInUltimateMode() const { return bIsInUltimateMode; }
	
	UFUNCTION(BlueprintPure, Category = "Ability")
	bool IsBasicAbility() const { return bIsBasicAbility; }

protected:
	void StartCooldown();
	void ResetCooldown();
	
	// Cached reference to resource manager
	UPROPERTY()
	UResourceManager* ResourceManager;
	
	// Helper to get resource manager
	UResourceManager* GetResourceManager() const;
	
	// Calculate heat generated by this ability
	float CalculateHeatGenerated() const;
	
	// Apply survivor buff modifiers
	virtual float GetDamageMultiplier() const;
	virtual float GetCooldownWithReduction() const;
	
	// Cached threshold manager
	UPROPERTY()
	UThresholdManager* ThresholdManager;
};